##
## Copyright 2018 by Girino Vey
##
## Licensed under Girino's Anarchist License
## http://www.girino.org/license
##

import grpc
import psutil
import os

# those files are generated by generate_stubs.py scrip
import api_pb2
import api_pb2_grpc


TransactionTypeEnum  = {
    'REGULAR' : 0,
    'COINBASE' : 4,
    'TICKET_PURCHASE' : 1,
    'VOTE' : 2,
    'REVOCATION' : 3
}

StatusTypeEnum = {
    'UNKNOWN' : 0,
    'IMMATURE' : 1,
    'LIVE' : 2,
    'VOTED' : 3,
    'REVOKED' : 4,
    'MISSED NOT REVOKED' : 5,
    'EXPIRED NOT REVOKED' : 6
}

def reverse_status(status):
    for key in StatusTypeEnum.keys():
        if StatusTypeEnum[key] == status:
            return key
    raise Exception('Status not found.')

def find_all_files(path, filename):
    matches = []
    for root, dirnames, filenames in os.walk(path):
        for fn in filenames:
            if fn.lower() == filename.lower():
                matches.append(os.path.join(root, fn))
    return matches

def to_hex(bin):
    return bin[::-1].encode('hex')

class WalletConnector:
    def __init__(self):
        self.found_certs = self.find_cert()
        self.init_channels()

    def find_cert(self):
        # looks for cert in linux
        home = os.path.expanduser('~')
        paths = [
            home + "/.config/decrediton/wallets/mainnet",
            os.path.expandvars('%APPDATA%\\decrediton\\wallets\\mainnet'),
            os.path.expandvars('%LOCALAPPDATA%\\decrediton\\wallets\\mainnet'),
            home + "/Library/Application Support/decrediton/wallets/mainnet",
            home + "/.dcrwallet",
            os.path.expandvars('%APPDATA%\\Dcrwallet'),
            os.path.expandvars('%LOCALAPPDATA%\\Dcrwallet'),
            home + "/Library/Application Support/dcrwallet"
        ]
        ret = []
        for path in paths:
            if os.path.isdir(path):
                ret = ret + find_all_files(path, 'rpc.cert')
        if not ret:
            raise Exception('Certificate file not found.')
        return ret
 
    def init_channels(self):
        dcrwallet_pid = None
        for  p in psutil.process_iter():
            if (p.name().lower() == 'dcrwallet') or (p.name().lower() == 'dcrwallet.exe') :
                dcrwallet_pid = p.pid
                break
        if dcrwallet_pid == None:
            raise Exception('Process \'dcrwallet\' could not be found.')

        # TODO: improve readability of this code
        self.channel = None
        for conn in psutil.Process(pid=dcrwallet_pid).connections():
            if conn.status == 'LISTEN':
                for cert in self.found_certs:
                    self.creds = grpc.ssl_channel_credentials(open(cert).read())
                    try:
                        self.channel = grpc.secure_channel('%s:%d' % (conn.laddr.ip, conn.laddr.port), self.creds)
                        self.wallet = api_pb2_grpc.WalletServiceStub(self.channel)
                        self.decoder = api_pb2_grpc.DecodeMessageServiceStub(self.channel)
                        # ping to test
                        self.wallet.Ping(api_pb2.PingRequest())
                        break
                    except grpc._channel._Rendezvous:
                        # ignore errors
                        self.channel = None
                else:
                    # if exited normally, go on
                    continue
                # if exited through break, break outer loop
                break
        if self.channel == None:
            raise Exception('Could not open connection to wallet.')

    def getTicketPurchases(self, type):
        ret = []
        all_txs = self.wallet.GetTransactions(api_pb2.GetTransactionsRequest())
        for blockinfo in all_txs:
            if hasattr (blockinfo, 'mined_transactions') and hasattr (blockinfo.mined_transactions, 'transactions'):
                for tx in blockinfo.mined_transactions.transactions:
                    if hasattr(tx, 'transaction_type') and tx.transaction_type == type:
                        ret.append(tx)
        return ret

    def map_by_type(self, transactionTypeEnum):
        ret = {}
        for tx in self.getTicketPurchases(transactionTypeEnum):
            # decode
            decoded = self.decoder.DecodeRawTransaction(api_pb2.DecodeRawTransactionRequest(serialized_transaction=tx.transaction))
            for input_ in decoded.transaction.inputs:
                ret[input_.previous_transaction_hash] = tx
        return ret

    def get_status(self, hash):
        if not hasattr(self, 'voted'):
            self.voted = self.map_by_type(TransactionTypeEnum['VOTE'])
        if not hasattr(self, 'revoked'):
            self.revoked = self.map_by_type(TransactionTypeEnum['REVOCATION'])
        if self.voted.has_key(hash):
            return StatusTypeEnum["VOTED"]
        if self.revoked.has_key(hash):
            return StatusTypeEnum["REVOKED"]
        tx_full = self.wallet.GetTransaction(api_pb2.GetTransactionRequest(transaction_hash=hash))
        if tx_full.confirmations < 256:
            return StatusTypeEnum["IMMATURE"]
        return StatusTypeEnum["LIVE"]

    def accumulate_ticket_data(self):
        ret = []
        for tx in self.getTicketPurchases(TransactionTypeEnum['TICKET_PURCHASE']):
            summary = {'txid' : to_hex(tx.hash), 
                        'status' : self.get_status(tx.hash),
                        'buy_date' : tx.timestamp,
                        'received' : 0.0,
                        'vote_date' : 0,
                        'vote_txid' : ''}
            summary['ticket_spent'] = sum([inpt.previous_amount for inpt in tx.debits])
            if self.voted.has_key(tx.hash):
                summary['received'] = sum([oupt.amount for oupt in self.voted[tx.hash].credits])
                summary['vote_date'] = self.voted[tx.hash].timestamp
                summary['vote_txid'] = to_hex(self.voted[tx.hash].hash)
            # try to find the split tx
            decoded = self.decoder.DecodeRawTransaction(api_pb2.DecodeRawTransactionRequest(serialized_transaction=tx.transaction)).transaction
            split = self.wallet.GetTransaction(api_pb2.GetTransactionRequest(transaction_hash=decoded.inputs[0].previous_transaction_hash)).transaction
            split_input = sum([inpt.previous_amount for inpt in split.debits])
            split_out = sum([oupt.amount for oupt in split.credits])

            # figure out the change, which is the
            # outputs from the split that are in this wallet 
            # but do not get spent by the ticket
            indexes = [inpt.index for inpt in tx.debits]
            previous_indexes = [decoded.inputs[z].previous_transaction_index for z in indexes]
            change = sum([oupt.amount for oupt in split.credits if not (oupt.index in previous_indexes)])
            summary['total_spent'] = split_input - change
            ret.append(summary)
        return ret

from datetime import datetime, date

def make_line(sizes, symbol, separator):
    ret = separator
    for i in sizes:
        ret = ret + (symbol * i) + separator
    return ret

def pretty_print(ticket_data):
    head = make_line([8,1,12,12,14,14, 8], '=', '+')
    split = make_line([8,1,12,12,14,14, 8], '-', '+')
    mask1  = '| %6s | %64s |'
    df = "{:%Y-%m-%d}"
    mask2  = '| %8s | %10s | %10s | %12.8f | %12.8f | %5.2f%% |'
    mask2b  = '| %8s | %10s | %10s | %12.8f | %12s | %6s |'
    mask_title2  = '| %8s | %10s | %10s | %12s | %12s | %6s |'

    print head
    print mask1 % ('TICKET', 'TXID TICKET' + (' ' * 53))
    print mask1 % ('VOTE', 'TXID VOTE' + (' ' * 55))
    print split
    print mask_title2 % ('STATUS', 'BUY DATE', 'VOTE DATE', 'AMOUNT SPENT', 'RECEIVED', 'PROFIT')

    for tx in ticket_data:
        print head
        print mask1 % ('ticket', tx['txid'])
        print mask1 % ('vote', tx['vote_txid'])
        print split
        profit = (tx['received'] - tx['total_spent'])*100.0/tx['total_spent']
        if tx['status'] == StatusTypeEnum['VOTED']:
            print mask2 % (reverse_status(tx['status']), 
                        df.format(datetime.fromtimestamp(tx['buy_date'])), df.format(datetime.fromtimestamp(tx['vote_date'])),
                        tx['total_spent']/1e8, tx['received']/1e8, profit)
        else:
            print mask2b % (reverse_status(tx['status']), 
                        df.format(datetime.fromtimestamp(tx['buy_date'])), '-',
                        tx['total_spent']/1e8, '-', '-')

    print head

if __name__ == '__main__':
    w = WalletConnector()

    # TODO: calculate ROI/time
    # TODO: add sorting and sorting cmd params
    # TODO: create GUI
    out = w.accumulate_ticket_data()

    pretty_print(out)
    raw_input('Press ENTER to close.')